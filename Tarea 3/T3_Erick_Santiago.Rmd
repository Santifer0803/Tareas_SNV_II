---
title: "T3_Erick_Santiago"
author: "Santiago Fernández y Erick Venegas"
date: "`r Sys.Date()`"
output: html_document
---

# Preparación

Se inicia cargando las librerías

```{r librerias}
pacman::p_load(ChainLadder,
               dplyr,
               ggplot2,
               lubridate,
               janitor,
               plotly,
               readxl)
```

Se cargan los datos correspondientes.

```{r carga_datos}
ejercicio_1 <- read_excel("data/Data Tarea 3.xlsx")
ejercicio_2 <- read_excel("data/Data_Ejercicio2.xlsx")
```

Adicionalmente, se agregan las primas para el primer ejercicio de forma manual, para no modificar el Excel correspondiente.

```{r primas_ej_1}
df_primas <- data.frame(
  años = 2005:2013,
  montos = c(
    26426000,
    34611000,
    40045000,
    44158000,
    48994000,
    52421000,
    56597000,
    59675000,
    59342000
  )
)
```


# Ejercicio 1

Para empezar el ejercicio, se colocan las columnas con el formato correspondiente.

```{r formato_fechas}
# Se corrige el nombre de las columnas
ejercicio_1 <- clean_names(ejercicio_1)

# Se corrige el formato de las fechas
ejercicio_1$fecha_notifi <- as.Date(ejercicio_1$fecha_notifi)
ejercicio_1$fecha_evento <- as.Date(ejercicio_1$fecha_evento)
```


## Inciso A

Para construir el triángulo de runoff, iniciaremos creando los índices correspondientes. Para esto, crearemos un índice iniciando en 0 para asignarle a cada uno de los años, al igual que otro con el año en el que se notificó el evento.

```{r indices_1}
# Índices de años de ocurrencia y desarrollo
ejercicio_1 <- ejercicio_1 %>%
  mutate(
    ocurrencia = year(fecha_evento) - min(year(fecha_evento)),
    desarrollo = year(fecha_notifi) - year(fecha_evento)
  )
```

Posteriormente, se procede a construir el triángulo de agotamiento. Se asume que el cálculo de la reserva se hará con la suma de los montos en cada índice de ocurrencia y desarrollo, no con la cantidad de siniestros presentados.

```{r triangulo_1}
# Se crea el  triángulo de runoff
triangulo_1 <-
  tapply(ejercicio_1$monto_siniestro, list(
    ejercicio_1$ocurrencia,
    ejercicio_1$desarrollo
  ), sum)

# Se muestra el triángulo de runoff para conprobar el resultado
triangulo_1
```

Como se puede apreciar, este es el triángulo de montos individuales, por lo que procedemos a calcular el de montos acumulados, el cual es necesario para todos los métodos posteriores.

```{r acumulados_1}
# Se convierte el triángulo de runoff incremental a uno acumulado
triangulo_1 <- incr2cum(triangulo_1)

# Se muestra el triángulo para combrobar el resultado
triangulo_1
```

Con esta información, podemos proceder con los 3 métodos requeridos.

## Inciso B

### Chain ladder

Iniciamos con el método de Chain ladder, pues es la base para los otros métodos. Para esto, iniciamos calculando los factores de desarrollo, tal y como se muestra en el [tutorial](https://cran.rstudio.com/web/packages/ChainLadder/vignettes/ChainLadder.html#using-the-chainladder-package) enviado por el profesor.

```{r factores_desarrollo_1}
# Se calculan los factores de desarrollo individuales
factores_desarrollo_1 <- sapply(1:(ncol(triangulo_1) - 1),
                                function(i) {
                                  sum(triangulo_1[c(1:(ncol(triangulo_1) - i)), i + 1]) / sum(triangulo_1[c(1:(ncol(triangulo_1) - i)), i])
                                })

# Se agrega el 1, correspondiente al último factor de desarrollo
factores_desarrollo_1 <- c(factores_desarrollo_1, 1)

# Con lo anterior, se calculan los factores de desarrollo acumulados
desarrollo_acum_1 <-
  cumprod(sort(factores_desarrollo_1, decreasing = FALSE))
```

Con los factores de desarrollo acumulados ($\lambda$), procedemos a calcular los pagos ultimate.

```{r ultimate_cl_1}
# Se extraen los últimos pagos conocidos
pagos_conocidos_1 <- sapply(1:nrow(triangulo_1), function(i) {
  triangulo_1[i, ncol(triangulo_1) - i + 1]
})

# Se calculan los pagos ultimate
ultimate_cl_1 <- pagos_conocidos_1 * desarrollo_acum_1

# Se muestran los últimos pagos conocidos y los ultimate
data.frame(ultimo_conocido = pagos_conocidos_1,
           ultimate_cl = ultimate_cl_1)
```

Finalmente, se calculan las reservas bajo el método de Chain Ladder.

```{r reserva_cl_1}
# Cálculo de la reserva
reserva_cl_1 <- ultimate_cl_1 - pagos_conocidos_1
reserva_tot_cl_1 <- sum(reserva_cl_1)

# Se muestra la reserva
reserva_cl_1
```

### Bornhuetter-Ferguson

Para este método requerimos de las primas acumuladas en el año, las cuales se calculan a través del ratio de siniestralidad (LR). Es decir, a través del ratio de siniestralidad del $80\%$ y las primas brutas dadas, podemos obtener las primas ($\mu$) necesarias.

```{r calculo_mu}
# Se calculan las primas correspondientes
primas_brutas <- df_primas$montos

# Se muestran las primas brutas
primas_brutas
```

Posteriormente, para seguir con este método se requieren los coeficientes $\beta_i = \frac{1}{\lambda_i}$, lo cual se muestra a continuación.

```{r calculo_betas}
# Cálculo de betas
betas <- 1 / desarrollo_acum_1
```

Con esta información, basta recordar la fórmula para los cálculos de los ultimate a través de BF:

$$\hat{C_{i, J} ^ {BF}} = C_{i, I - i} + (1 - \beta_{I - i}) \cdot \mu_i$$

Con lo cual, los pagos ultimate son:

```{r ultimate_BF}
# Cálculo de ultimate de Bornhuetter-Ferguson
ultimate_bf <- pagos_conocidos_1 + (1 - betas) * primas_brutas
```

Finalmente, se calculan las reservas correspondientes:

```{r reservas_bf}
# Cálculo de la reserva
reserva_bf <- ultimate_bf - pagos_conocidos_1
reserva_tot_bf <- sum(reserva_bf)

# Se muestra la reserva
reserva_bf
```

### Cape Cod

En este caso tenemos la mayoría de elementos, basta con calcular la razón de siniestralidad global robusta ($\hat{\kappa} ^ {CC}$).

$$\hat{\kappa} ^ {CC} = \dfrac{\sum_{i = 0} ^ I C_{i, I - i}}{\sum_{i = 0} ^ I \beta_{I - i} \cdot \Pi_i}$$

Por lo que su cálculo es el siguiente:

```{r kappa_cc}
# Se calcula el factor kappa
kappa_cc <- sum(pagos_conocidos_1) / sum(betas * primas_brutas)
```

Se calculan los ultimate correspondientes.

```{r ultimate_cc}
# Cálculo del ultimate
ultimate_cc <- pagos_conocidos_1 + (1 - betas) * kappa_cc * primas_brutas
```

Finalmente, se calcula la reserva correspondiente.

```{r reserva_cc}
# Cálculo de la reserva
reserva_cc <- ultimate_cc - pagos_conocidos_1
reserva_tot_cc <- sum(reserva_cc)

# Se muestra la reserva
reserva_cc
```

## Inciso C

Para iniciar el análisis, se procede a graficar la estimación de $\mu$ de los métodos de Bornhuetter Ferguson y Cape Cod, para ver el impacto que este podría tener en la reserva.

```{r prima_metodos, warning = FALSE}
# Se juntan los datos requeridos en un solo dataframe y se grafica
(
  data.frame(
    "indice" = 0:8,
    "prima_bf" = primas_brutas,
    "prima_cc" = kappa_cc * primas_brutas
  ) %>% ggplot(aes(x = indice)) +
    geom_line(aes(y = prima_bf / 1000000, color = "BF")) +
    geom_point(aes(
      y = prima_bf / 1000000,
      color = "BF",
      text = paste(
        "Método: BF",
        "<br>Prima:",
        round(prima_bf / 1e6, 2),
        "millones",
        "<br>Año:",
        indice
      )
    )) +
    geom_line(aes(y = prima_cc / 1000000, color = "CC")) +
    geom_point(aes(
      y = prima_cc / 1000000,
      color = "CC",
      text = paste(
        "Método: CC",
        "<br>Prima:",
        round(prima_cc / 1e6, 2),
        "millones",
        "<br>Año:",
        indice
      )
    )) +
    labs(x = "Año de ocurrencia", y = "Prima (millones de colones)", color = "Método") +
    theme_minimal()
) %>%
  ggplotly(tooltip = "text")
```

En el gráfico anterior, se

Además, como se puede apreciar en la siguiente figura, esta diferencia en la estimación de primas tiene un gran impacto en las reservas a lo largo del tiempo:

```{r prima_metodos, warning = FALSE}
# Se juntan los datos requeridos en un solo dataframe y se grafica
(
  data.frame(
    "indice" = 0:8,
    "reserva_cl" = reserva_cl_1,
    "reserva_bf" = reserva_bf,
    "reserva_cc" = reserva_cc
  ) %>% ggplot(aes(x = indice)) +
    geom_line(aes(y = reserva_cl / 1000000, color = "CL")) +
    geom_point(aes(
      y = reserva_cl / 1000000,
      color = "CL",
      text = paste(
        "Método: CL",
        "<br>Prima:",
        round(reserva_cl / 1e6, 2),
        "millones",
        "<br>Año:",
        indice
      )
    )) +
    geom_line(aes(y = reserva_bf / 1000000, color = "BF")) +
    geom_point(aes(
      y = reserva_bf / 1000000,
      color = "BF",
      text = paste(
        "Método: BF",
        "<br>Prima:",
        round(reserva_bf / 1e6, 2),
        "millones",
        "<br>Año:",
        indice
      )
    )) +
    geom_line(aes(y = reserva_cc / 1000000, color = "CC")) +
    geom_point(aes(
      y = reserva_cc / 1000000,
      color = "CC",
      text = paste(
        "Método: CC",
        "<br>Prima:",
        round(reserva_cc / 1e6, 2),
        "millones",
        "<br>Año:",
        indice
      )
    )) +
    labs(x = "Año de ocurrencia", y = "Prima (millones de colones)", color = "Método") +
    theme_minimal()
) %>%
  ggplotly(tooltip = "text")
```

Se observa que las reservas de Bornhuetter Ferguson y Cape Con poseen tendencias similares hasta el sexto periodo, con algunas diferencias debido a la sobreestimación de primas mencionada anteriormente. No obstante, en los últimos periodos, en donde hay menos datos y, por tanto, mayor variabilidad, 

# Ejercicio 2

A