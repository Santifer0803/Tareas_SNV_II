---
title: "T3_Erick_Santiago"
author: "Santiago Fernández y Erick Venegas"
date: "`r Sys.Date()`"
output: html_document
---

# Preparación

Se inicia cargando las librerías

```{r librerias}
pacman::p_load(ChainLadder,
               dplyr,
               ggplot2,
               lubridate,
               janitor,
               plotly,
               readxl)
```

Se cargan los datos correspondientes.

```{r carga_datos}
ejercicio_1 <- read_excel("data/Data Tarea 3.xlsx")
ejercicio_2 <- read_excel("data/Data_Ejercicio2.xlsx")
```

Adicionalmente, se agregan las primas para el primer ejercicio de forma manual, para no modificar el Excel correspondiente.

```{r primas_ej_1}
df_primas <- data.frame(
  años = 2005:2013,
  montos = c(
    26426000,
    34611000,
    40045000,
    44158000,
    48994000,
    52421000,
    56597000,
    59675000,
    59342000
  )
)
```


# Ejercicio 1

Para empezar el ejercicio, se colocan las columnas con el formato correspondiente.

```{r formato_fechas}
# Se corrige el nombre de las columnas
ejercicio_1 <- clean_names(ejercicio_1)

# Se corrige el formato de las fechas
ejercicio_1$fecha_notifi <- as.Date(ejercicio_1$fecha_notifi)
ejercicio_1$fecha_evento <- as.Date(ejercicio_1$fecha_evento)
```


## Inciso A

Para construir el triángulo de runoff, iniciaremos creando los índices correspondientes. Para esto, crearemos un índice iniciando en 0 para asignarle a cada uno de los años, al igual que otro con el año en el que se notificó el evento.

```{r indices_1}
# Índices de años de ocurrencia y desarrollo
ejercicio_1 <- ejercicio_1 %>%
  mutate(
    ocurrencia = year(fecha_evento) - min(year(fecha_evento)),
    desarrollo = year(fecha_notifi) - year(fecha_evento)
  )
```

Posteriormente, se procede a construir el triángulo de agotamiento a través de la función pedida. Se asume que el cálculo de la reserva se hará con la suma de los montos en cada índice de ocurrencia y desarrollo, no con la cantidad de siniestros presentados.

```{r triangulo_1}
# Se crea la función del triángulo de runoff
df_triangulo <- function(montos, ocurrencia, desarrollo) {
  # Triángulo de agotamiento
  triangulo <-
    tapply(montos,
           list(ocurrencia,
                desarrollo),
           sum)
  
  # Se devuelve el triángulo de agotamiento
  return(triangulo)
}

# Se crea el triángulo
triangulo_1 <- df_triangulo(montos = ejercicio_1$monto_siniestro,
                            ocurrencia = ejercicio_1$ocurrencia,
                            desarrollo = ejercicio_1$desarrollo)
```

Como se puede apreciar, este es el triángulo de montos individuales, por lo que procedemos a calcular el de montos acumulados, el cual es necesario para todos los métodos posteriores.

```{r acumulados_1}
# Se convierte el triángulo de runoff incremental a uno acumulado
triangulo_1 <- incr2cum(triangulo_1)

# Se muestra el triángulo para combrobar el resultado
triangulo_1
```

Con esta información, podemos proceder con los 3 métodos requeridos.

## Inciso B

### Chain ladder

Iniciamos con el método de Chain ladder, pues es la base para los otros métodos. Para esto, iniciamos calculando los factores de desarrollo, tal y como se muestra en el [tutorial](https://cran.rstudio.com/web/packages/ChainLadder/vignettes/ChainLadder.html#using-the-chainladder-package) enviado por el profesor.

```{r factores_desarrollo_1}
# Se calculan los factores de desarrollo individuales
factores_desarrollo_1 <- sapply(1:(ncol(triangulo_1) - 1),
                                function(i) {
                                  sum(triangulo_1[c(1:(ncol(triangulo_1) - i)), i + 1]) / sum(triangulo_1[c(1:(ncol(triangulo_1) - i)), i])
                                })

# Se agrega el 1, correspondiente al último factor de desarrollo
factores_desarrollo_1 <- c(factores_desarrollo_1, 1)

# Con lo anterior, se calculan los factores de desarrollo acumulados
desarrollo_acum_1 <-
  cumprod(sort(factores_desarrollo_1, decreasing = FALSE))
```

Con los factores de desarrollo acumulados ($\lambda$), procedemos a calcular los pagos ultimate.

```{r ultimate_cl_1}
# Se extraen los últimos pagos conocidos
pagos_conocidos_1 <- sapply(1:nrow(triangulo_1), function(i) {
  triangulo_1[i, ncol(triangulo_1) - i + 1]
})

# Se calculan los pagos ultimate
ultimate_cl_1 <- pagos_conocidos_1 * desarrollo_acum_1

# Se muestran los últimos pagos conocidos y los ultimate
data.frame(ultimo_conocido = pagos_conocidos_1,
           ultimate_cl = ultimate_cl_1)
```

Finalmente, se calculan las reservas bajo el método de Chain Ladder.

```{r reserva_cl_1}
# Cálculo de la reserva
reserva_cl_1 <- ultimate_cl_1 - pagos_conocidos_1
reserva_tot_cl_1 <- sum(reserva_cl_1)

# Se muestra la reserva
reserva_cl_1
```

### Bornhuetter-Ferguson

Para este método requerimos de las primas acumuladas en el año, las cuales se calculan a través del ratio de siniestralidad (LR). Es decir, a través del ratio de siniestralidad del $80\%$ y las primas brutas dadas, podemos obtener las primas ($\mu$) necesarias.

```{r calculo_mu}
# Se calculan las primas correspondientes
primas_brutas <- df_primas$montos

# Se muestran las primas brutas
primas_brutas
```

Posteriormente, para seguir con este método se requieren los coeficientes $\beta_i = \frac{1}{\lambda_i}$, lo cual se muestra a continuación.

```{r calculo_betas}
# Cálculo de betas
betas <- 1 / desarrollo_acum_1
```

Con esta información, basta recordar la fórmula para los cálculos de los ultimate a través de BF:

$$\hat{C_{i, J} ^ {BF}} = C_{i, I - i} + (1 - \beta_{I - i}) \cdot \mu_i$$

Con lo cual, los pagos ultimate son:

```{r ultimate_BF}
# Cálculo de ultimate de Bornhuetter-Ferguson
ultimate_bf <- pagos_conocidos_1 + (1 - betas) * primas_brutas
```

Finalmente, se calculan las reservas correspondientes:

```{r reservas_bf}
# Cálculo de la reserva
reserva_bf <- ultimate_bf - pagos_conocidos_1
reserva_tot_bf <- sum(reserva_bf)

# Se muestra la reserva
reserva_bf
```

### Cape Cod

En este caso tenemos la mayoría de elementos, basta con calcular la razón de siniestralidad global robusta ($\hat{\kappa} ^ {CC}$).

$$\hat{\kappa} ^ {CC} = \dfrac{\sum_{i = 0} ^ I C_{i, I - i}}{\sum_{i = 0} ^ I \beta_{I - i} \cdot \Pi_i}$$

Por lo que su cálculo es el siguiente:

```{r kappa_cc}
# Se calcula el factor kappa
kappa_cc <- sum(pagos_conocidos_1) / sum(betas * primas_brutas)
```

Se calculan los ultimate correspondientes.

```{r ultimate_cc}
# Cálculo del ultimate
ultimate_cc <- pagos_conocidos_1 + (1 - betas) * kappa_cc * primas_brutas
```

Finalmente, se calcula la reserva correspondiente.

```{r reserva_cc}
# Cálculo de la reserva
reserva_cc <- ultimate_cc - pagos_conocidos_1
reserva_tot_cc <- sum(reserva_cc)

# Se muestra la reserva
reserva_cc
```

## Inciso C

Para iniciar el análisis, se procede a graficar la estimación de $\mu$ de los métodos de Bornhuetter Ferguson y Cape Cod, para ver el impacto que este podría tener en la reserva.

```{r prima_metodos, warning = FALSE}
# Se juntan los datos requeridos en un solo dataframe y se grafica
(
  data.frame(
    "indice" = 0:8,
    "prima_bf" = primas_brutas,
    "prima_cc" = kappa_cc * primas_brutas
  ) %>% ggplot(aes(x = indice)) +
    geom_line(aes(y = prima_bf / 1000000, color = "BF")) +
    geom_point(aes(
      y = prima_bf / 1000000,
      color = "BF",
      text = paste(
        "Método: BF",
        "<br>Prima:",
        round(prima_bf / 1e6, 2),
        "millones",
        "<br>Año:",
        indice
      )
    )) +
    geom_line(aes(y = prima_cc / 1000000, color = "CC")) +
    geom_point(aes(
      y = prima_cc / 1000000,
      color = "CC",
      text = paste(
        "Método: CC",
        "<br>Prima:",
        round(prima_cc / 1e6, 2),
        "millones",
        "<br>Año:",
        indice
      )
    )) +
    labs(x = "Año de ocurrencia", y = "Prima (millones de colones)", color = "Método") +
    theme_minimal()
) %>%
  ggplotly(tooltip = "text")
```

En el gráfico anterior, se puede ver que las primas utilizadas para la estimación de los pagos ultimate es considerablemente mayor en el proceso de Bornhuetter Ferguson, esto a causa del parámetro $\hat{\kappa} < 1$, el cual indica que tenemos ganancias en la empresa correspondiente. En particular, se puede apreciar que las primas del método de Bornhuetter Ferguson son más del doble de las estimadas por la metodología de Cape Cod.

Hay que recordar que, a pesar de tener diferencias, los métodos de Bornhuetter Ferguson y Cape Cod utilizan una ponderación entre la estimación del método Chain Ladder y una prima exógena (BF) o ajustada (CC). Por lo cual, entre menos información disponible exista en los datos, la estimación exógena/ajustada cobrará más peso para el cálculo del pago ultimate.

Por lo anterior, esta diferencia en la estimación de primas tiene un gran impacto en las reservas a lo largo del tiempo, como se aprecia en la siguiente figura:

```{r reservas_anuales, warning = FALSE}
# Se juntan los datos requeridos en un solo dataframe y se grafica
(
  data.frame(
    "indice" = 0:8,
    "reserva_cl" = reserva_cl_1,
    "reserva_bf" = reserva_bf,
    "reserva_cc" = reserva_cc
  ) %>% ggplot(aes(x = indice)) +
    geom_line(aes(y = reserva_cl / 1000000, color = "CL")) +
    geom_point(aes(
      y = reserva_cl / 1000000,
      color = "CL",
      text = paste(
        "Método: CL",
        "<br>Prima:",
        round(reserva_cl / 1e6, 2),
        "millones",
        "<br>Año:",
        indice
      )
    )) +
    geom_line(aes(y = reserva_bf / 1000000, color = "BF")) +
    geom_point(aes(
      y = reserva_bf / 1000000,
      color = "BF",
      text = paste(
        "Método: BF",
        "<br>Prima:",
        round(reserva_bf / 1e6, 2),
        "millones",
        "<br>Año:",
        indice
      )
    )) +
    geom_line(aes(y = reserva_cc / 1000000, color = "CC")) +
    geom_point(aes(
      y = reserva_cc / 1000000,
      color = "CC",
      text = paste(
        "Método: CC",
        "<br>Prima:",
        round(reserva_cc / 1e6, 2),
        "millones",
        "<br>Año:",
        indice
      )
    )) +
    labs(x = "Año de ocurrencia", y = "Reserva (millones de colones)", color = "Método") +
    theme_minimal()
) %>%
  ggplotly(tooltip = "text")
```

Es claro que los métodos de Chain Ladder y Cape Cod presentan resultados similares, mientras que, el método de Bornhuetter Ferguson parece estar sobreestimando las reservas requeridas anualmente. Esto último, una vez más, se justifica con las primas utilizadas para la estimación de esta metodología, lo que resulta claro por la gran diferencia que existe entre este procedimiento y los otros 2.

Todo parece indicar que el método de Bornhuetter Ferguson, bajo condiciones normales, no es la mejor opción a elegir, pues se estaría siendo demasiado conservador. Por otro lado, resulta difícil elegir entre los métodos de Cape Cod y Chain Ladder, pues parece que otorgan resultados bastante similares.

Para dilucidar una opción, se muestra la reserva total de cada uno de los 3 métodos implementados:

```{r reservas_totales}
# Se juntan los datos y se grafican
(
  data.frame(
    metodo = c("Chain Ladder", "Bornhuetter Ferguson", "Cape Cod"),
    reserva = c(reserva_tot_cl_1, reserva_tot_bf, reserva_tot_cc),
    texto = paste(
      "Método:",
      c("Chain Ladder", "Bornhuetter Ferguson", "Cape Cod"),
      "<br>Reserva:",
      round(c(
        reserva_tot_cl_1, reserva_tot_bf, reserva_tot_cc
      ) / 1e6, 2),
      "millones"
    )
  ) %>% ggplot(aes(
    x = metodo,
    y = reserva / 1e6,
    fill = metodo,
    text = texto
  )) +
    geom_col(width = 0.6) +
    labs(x = "Método",
         y = "Reserva (millones de colones)",
         fill = "Método") +
    theme_minimal()
) %>%
  ggplotly(tooltip = "text") %>%
  layout(showlegend = FALSE)
```

En esta última figura se vuelve a destacar el valor de Bornhuetter Ferguson, pues supera en casi 100 millones de colones a la reserva de Cape Cod, la cual es la siguiente más grande. Con esto se descarta definitivamente esta opción (BF), se estaría creando un ahorro excesivo sin motivo aparente, pues, nuevamente, queda claro que se sobreestima el valor requerido.

Con respecto a Cape Cod y Chain Ladder, se puede ver que el primero es ligeramente más conservador que Chain Ladder, pues la reserva es mayor. Aunque, a nivel práctico, la diferencia es tan pequeña (en término del dinero que mueve la empresa) que son prácticamente iguales.

En conclusión, al órgano de dirección de la empresa le recomendaría, en lo personal, la reserva obtenida a través del método de Chain Ladder. Esto debido, en primer lugar, al resultado obtenido en comparación a los demás métodos, pues se comprueba que es muy similar a una metodología robusta como el proceso de Cape Cod. Además, es claro que es el método más sencillo de implementar y entender, por lo cual, favorece a la parsimonia del modelo.

# Ejercicio 2

A